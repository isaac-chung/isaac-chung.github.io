"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8066],{8874:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>h});var o=n(5893),a=n(1151);n(5124);const i={slug:"rag-eval-and-observability",title:"How to really know if your RAG system is working well.",authors:["ichung"],tags:["RAG","LLM","Evaluation","Tracing","Logging","Observability"],enableComments:!0},s=void 0,r={permalink:"/blog/rag-eval-and-observability",source:"@site/blog/2024-03-24-rag-eval-and-observability/index.md",title:"How to really know if your RAG system is working well.",description:"We know that building a Retrieval Augmented Generation (RAG) proof of concept is easy, but making it production-ready can be hard. There are no shortage of tips and tricks out there for us to try, but at the end of the day, it all depends on our data and our application. Transitioning RAG into production follows similar principles to other production systems. Scaling up to handle more data and users, smooth error/exception handling, and getting it to play nice with other systems are some of the main challenges to tackle. How can we really know if our RAG system is working well? and how well? To find out, we should take a look at each component under the hood and be able to evaluate the pipeline with clear metrics.",date:"2024-03-24T00:00:00.000Z",formattedDate:"March 24, 2024",tags:[{label:"RAG",permalink:"/blog/tags/rag"},{label:"LLM",permalink:"/blog/tags/llm"},{label:"Evaluation",permalink:"/blog/tags/evaluation"},{label:"Tracing",permalink:"/blog/tags/tracing"},{label:"Logging",permalink:"/blog/tags/logging"},{label:"Observability",permalink:"/blog/tags/observability"}],readingTime:3.0533333333333332,hasTruncateMarker:!0,authors:[{name:"Isaac Chung",title:"Senior Research Engineer @ Clarifai",url:"https://isaac-chung.github.io",imageURL:"https://github.com/isaac-chung.png",key:"ichung"}],frontMatter:{slug:"rag-eval-and-observability",title:"How to really know if your RAG system is working well.",authors:["ichung"],tags:["RAG","LLM","Evaluation","Tracing","Logging","Observability"],enableComments:!0},unlisted:!1,nextItem:{title:"All about Timing: A quick look at metrics for LLM serving",permalink:"/blog/llm-serving"}},l={authorsImageUrls:[void 0]},h=[{value:"How to look under the hood in a RAG system?",id:"how-to-look-under-the-hood-in-a-rag-system",level:2},{value:"How to evaluate RAG systems?",id:"how-to-evaluate-rag-systems",level:2},{value:"The Bottom Line",id:"the-bottom-line",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const t={a:"a",admonition:"admonition",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"We know that building a Retrieval Augmented Generation (RAG) proof of concept is easy, but making it production-ready can be hard. There are no shortage of tips and tricks out there for us to try, but at the end of the day, it all depends on our data and our application. Transitioning RAG into production follows similar principles to other production systems. Scaling up to handle more data and users, smooth error/exception handling, and getting it to play nice with other systems are some of the main challenges to tackle. How can we really know if our RAG system is working well? and how well? To find out, we should take a look at each component under the hood and be able to evaluate the pipeline with clear metrics."}),"\n",(0,o.jsx)(t.admonition,{title:"Key questions I'll address are:",type:"tip",children:(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"How to look under the hood in a RAG system?"}),"\n",(0,o.jsx)(t.li,{children:"How to evaluate RAG systems?"}),"\n"]})}),"\n",(0,o.jsx)(t.h2,{id:"how-to-look-under-the-hood-in-a-rag-system",children:"How to look under the hood in a RAG system?"}),"\n",(0,o.jsxs)(t.p,{children:["Once the components are set up in the RAG system, it is tempting to spot-check it for performance, and try out some ",(0,o.jsx)(t.em,{children:"advanced techniques"})," with the promise of performance improvements. However, this isn't the most reliable nor structural approach to debugging and improving RAG. The first thing we should do after getting our first end-to-end RAG response is adding observability. This greatly helps us not only during the transition of our RAG system from POC to production but also in its post-launch maintenance phase."]}),"\n",(0,o.jsx)(t.p,{children:"Observability is crucial in RAG production systems for several main reasons:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Detecting Issues"}),": Observability allows for the detection of issues and anomalies within a system. By monitoring various metrics, logs, and traces, we can quickly identify when something goes wrong and take appropriate action to resolve the issue before it impacts users."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Root Cause Analysis"}),": When problems occur, especially during the development phase, observability enables us to perform root cause analysis efficiently. By examining the data collected from various components, we can trace back the source of the problem and address it effectively. More important, in production this would help reduce downtime and minimizing the impact on users."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Performance Optimization"}),": Observability provides insights into the performance of the system. By monitoring metrics such as response times, throughput, and resource utilization, we can identify bottlenecks and areas for optimization, leading to better overall performance and user experience."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["This could be as simple as logging inputs and outputs of each component (e.g. simple setting in ",(0,o.jsx)(t.a,{href:"https://docs.llamaindex.ai/en/stable/module_guides/observability/#simple-llm-inputsoutputs",children:"llama-index"}),"). There are a variety of LLM observability tools to help trace the timings and outputs at each step of a RAG system. Some of these have minimal config needed, have no pricing page, and are open source, and they are:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"https://github.com/traceloop/openllmetry",children:"OpenLLMetry"}),": Built on top of OpenTelemetry. If you\u2019re using an LLM framework like Haystack, Langchain or LlamaIndex, there is no need to add any annotations to your code."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"https://github.com/Arize-ai/phoenix",children:"Arize Phoenix"}),': Built on top of the OpenInference tracing standard, and uses it to trace, export, and collect critical information about your LLM Application in the form of "spans". It also supports several RAG-related analyses and visualizations.']}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"how-to-evaluate-rag-systems",children:"How to evaluate RAG systems?"}),"\n",(0,o.jsx)(t.p,{children:"Just like any system, it is important to understand how well the RAG system is performing and how much improvement has been achieved over the baseline. This doesn\u2019t just involve measuring how fast and how much it costs, but also how good the outputs are. We could take a look at RAG-specific evaluation methods. Per-component evaluations, like unit tests, can be done on the retrieval stage and the generation stage separately."}),"\n",(0,o.jsx)(t.p,{children:"For retrieval, the goal is to find out given the configuration how well can the system retrieve relevant results? Here you would need a golden set of queries and ground truth of relevant documents (or their IDs).  You could use IR metrics like nDCG or Mean Reciprocal Rank (MRR), but for RAG it\u2019s more meaningful to understand 1) the signal to noise ratio of the retrieved context (context precision) and 2) how well it can retrieve all the relevant information required to answer the question (context recall)."}),"\n",(0,o.jsx)(t.p,{children:"For generation, the goal is to find out, given the relevant documents in the context, 1) how factually accurate is the generated answer (faithfulness), and 2) how relevant is the generated answer to the question (answer relevancy). It is also important to evaluate the full pipeline end to end. This might involve some manual efforts to start with or asking an LLM to verify whether the answer is correct. A proxy for gauging how close the generated answer to the ground truth answer could be semantic similarity."}),"\n",(0,o.jsxs)(t.p,{children:["Some open source RAG evaluation tools like ",(0,o.jsx)(t.a,{href:"https://github.com/explodinggradients/ragas",children:"Ragas"})," offer readily available guide to evaluate your RAG system with predefined metrics and iterate your RAG system with user feedback in production. Ragas, in particular, offers the ability generate a synthetic test set for \u201creference-free\u201d evaluation, which means that instead of relying on human-annotated test set, Ragas leverages LLMs under the hood to conduct the evaluations."]}),"\n",(0,o.jsx)(t.h2,{id:"the-bottom-line",children:"The Bottom Line"}),"\n",(0,o.jsx)(t.p,{children:"Fight the urge of treating the RAG system as a black box. Use a structured approach to evaluate your RAG system in terms of performance and other requirements like latency by adding observability and using evaluation tools."}),"\n",(0,o.jsx)(t.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Catch this talk on ",(0,o.jsx)(t.a,{href:"https://pycon.lt/2024/talks/HFXHRV",children:'"Transcend the Knowledge Barriers in RAG"'})," at PyCon Lithuania to understand how each RAG component works under the hood."]}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://towardsdatascience.com/12-rag-pain-points-and-proposed-solutions-43709939a28c",children:"12 RAG Pain points"})}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},5124:(e,t,n)=>{n.d(t,{Z:()=>s});var o=n(7294),a=n(9276),i=n(5893);function s(e){let{image:t,alt:s,caption:r}=e;const[l,h]=(0,o.useState)({width:0,height:0}),d=r.split("\\n").map(((e,t,n)=>(0,i.jsxs)(o.Fragment,{children:[e,t<n.length-1&&(0,i.jsx)("br",{})]},t)));return(0,o.useEffect)((()=>{const e=new Image;e.onload=()=>{h({width:e.naturalWidth,height:e.naturalHeight})},e.src=t;const o=new a.Z({gallery:"#figure-gallery",children:"a",pswpModule:()=>n.e(5826).then(n.bind(n,7766))});return o.init(),()=>{o.destroy()}}),[t]),(0,i.jsxs)("figure",{style:{border:"1px dashed rgba(0, 0, 0, .1)",padding:0,margin:0,marginBottom:20,borderRadius:"15px",textAlign:"right"},id:"figure-gallery",children:[(0,i.jsx)("a",{href:t,"data-pswp-width":l.width,"data-pswp-height":l.height,children:(0,i.jsx)("img",{src:t,alt:s,style:{maxWidth:"100%",height:"auto"}})}),(0,i.jsx)("hr",{style:{margin:"5px 0",backgroundColor:"rgba(0, 0, 0, .2)"}}),(0,i.jsx)("figcaption",{style:{marginTop:"0.5em",marginBottom:"0.5em",marginRight:"1em",textAlign:"right",fontSize:"0.8em"},children:d})]})}}}]);